; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; This test contains extremely tricky call graph structures for the inliner to
; handle correctly. They form cycles where the inliner introduces code that is
; immediately or can eventually be transformed back into the original code. And
; each step changes the call graph and so will trigger iteration. This requires
; some out-of-band way to prevent infinitely re-inlining and re-transforming the
; code.
;
; RUN: opt < %s -passes='cgscc(inline,function(sroa,instcombine))' -inline-threshold=50 -S | FileCheck %s


; The `test1_*` collection of functions form a directly cycling pattern.

define void @test1_a(ptr %ptr) {
; CHECK-LABEL: define void @test1_a
; CHECK-SAME: (ptr [[PTR:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @test1_b(ptr nonnull @test1_b, i1 false, i32 1)
; CHECK-NEXT:    ret void
;
entry:
  call void @test1_b(ptr @test1_b, i1 false, i32 0)
; Inlining and simplifying this call will reliably produce the exact same call,
; over and over again. However, each inlining increments the count, and so we
; expect this test case to stop after one round of inlining with a final
; argument of '1'.

  ret void
}

define void @test1_b(ptr %arg, i1 %flag, i32 %inline_count) {
; CHECK-LABEL: define void @test1_b
; CHECK-SAME: (ptr [[ARG:%.*]], i1 [[FLAG:%.*]], i32 [[INLINE_COUNT:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[ARG]], ptr [[A]], align 8
; CHECK-NEXT:    br i1 [[FLAG]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    call void @test1_a(ptr nonnull [[A]]) #[[ATTR0:[0-9]+]]
; CHECK-NEXT:    br label [[BB2]]
; CHECK:       bb2:
; CHECK-NEXT:    [[P:%.*]] = load ptr, ptr [[A]], align 8
; CHECK-NEXT:    [[INLINE_COUNT_INC:%.*]] = add i32 [[INLINE_COUNT]], 1
; CHECK-NEXT:    call void [[P]](ptr [[ARG]], i1 [[FLAG]], i32 [[INLINE_COUNT_INC]])
; CHECK-NEXT:    ret void
;
entry:
  %a = alloca ptr
  store ptr %arg, ptr %a
; This alloca and store should remain through any optimization.

  br i1 %flag, label %bb1, label %bb2

bb1:
  call void @test1_a(ptr %a) noinline
  br label %bb2

bb2:
  %p = load ptr, ptr %a
  %inline_count_inc = add i32 %inline_count, 1
  call void %p(ptr %arg, i1 %flag, i32 %inline_count_inc)
; And we should continue to load and call indirectly through optimization.

  ret void
}

define void @test2_a(ptr %ptr) {
; CHECK-LABEL: define void @test2_a
; CHECK-SAME: (ptr [[PTR:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @test2_b(ptr nonnull @test2_b, ptr nonnull @test2_c, i1 false, i32 2)
; CHECK-NEXT:    ret void
;
entry:
  call void @test2_b(ptr @test2_b, ptr @test2_c, i1 false, i32 0)
; Inlining and simplifying this call will reliably produce the exact same call,
; but only after doing two rounds if inlining, first from @test2_b then
; @test2_c. We check the exact number of inlining rounds before we cut off to
; break the cycle by inspecting the last paramater that gets incremented with
; each inlined function body.
  ret void
}

define void @test2_b(ptr %arg1, ptr %arg2, i1 %flag, i32 %inline_count) {
; CHECK-LABEL: define void @test2_b
; CHECK-SAME: (ptr [[ARG1:%.*]], ptr [[ARG2:%.*]], i1 [[FLAG:%.*]], i32 [[INLINE_COUNT:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[ARG2]], ptr [[A]], align 8
; CHECK-NEXT:    br i1 [[FLAG]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    call void @test2_a(ptr nonnull [[A]]) #[[ATTR0]]
; CHECK-NEXT:    br label [[BB2]]
; CHECK:       bb2:
; CHECK-NEXT:    [[P:%.*]] = load ptr, ptr [[A]], align 8
; CHECK-NEXT:    [[INLINE_COUNT_INC:%.*]] = add i32 [[INLINE_COUNT]], 1
; CHECK-NEXT:    call void [[P]](ptr [[ARG1]], ptr [[ARG2]], i1 [[FLAG]], i32 [[INLINE_COUNT_INC]])
; CHECK-NEXT:    ret void
;
entry:
  %a = alloca ptr
  store ptr %arg2, ptr %a
; This alloca and store should remain through any optimization.

  br i1 %flag, label %bb1, label %bb2

bb1:
  call void @test2_a(ptr %a) noinline
  br label %bb2

bb2:
  %p = load ptr, ptr %a
  %inline_count_inc = add i32 %inline_count, 1
  call void %p(ptr %arg1, ptr %arg2, i1 %flag, i32 %inline_count_inc)
; And we should continue to load and call indirectly through optimization.

  ret void
}

define void @test2_c(ptr %arg1, ptr %arg2, i1 %flag, i32 %inline_count) {
; CHECK-LABEL: define void @test2_c
; CHECK-SAME: (ptr [[ARG1:%.*]], ptr [[ARG2:%.*]], i1 [[FLAG:%.*]], i32 [[INLINE_COUNT:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[ARG1]], ptr [[A]], align 8
; CHECK-NEXT:    br i1 [[FLAG]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    call void @test2_a(ptr nonnull [[A]]) #[[ATTR0]]
; CHECK-NEXT:    br label [[BB2]]
; CHECK:       bb2:
; CHECK-NEXT:    [[P:%.*]] = load ptr, ptr [[A]], align 8
; CHECK-NEXT:    [[INLINE_COUNT_INC:%.*]] = add i32 [[INLINE_COUNT]], 1
; CHECK-NEXT:    call void [[P]](ptr [[ARG1]], ptr [[ARG2]], i1 [[FLAG]], i32 [[INLINE_COUNT_INC]])
; CHECK-NEXT:    ret void
;
entry:
  %a = alloca ptr
  store ptr %arg1, ptr %a
; This alloca and store should remain through any optimization.

  br i1 %flag, label %bb1, label %bb2

bb1:
  call void @test2_a(ptr %a) noinline
  br label %bb2

bb2:
  %p = load ptr, ptr %a
  %inline_count_inc = add i32 %inline_count, 1
  call void %p(ptr %arg1, ptr %arg2, i1 %flag, i32 %inline_count_inc)
; And we should continue to load and call indirectly through optimization.

  ret void
}

; Another infinite inlining case. The initial callgraph is like following:
;
;         test3_a <---> test3_b
;             |         ^
;             v         |
;         test3_c <---> test3_d
;
; For all the call edges in the call graph, only test3_c and test3_d can be
; inlined into test3_a, and no other call edge can be inlined.
;
; After test3_c is inlined into test3_a, the original call edge test3_a->test3_c
; will be removed, a new call edge will be added and the call graph becomes:
;
;            test3_a <---> test3_b
;                  \      ^
;                   v    /
;     test3_c <---> test3_d
; But test3_a, test3_b, test3_c and test3_d still belong to the same SCC.
;
; Then after test3_a->test3_d is inlined, when test3_a->test3_d is converted to
; a ref edge, the original SCC will be split into two: {test3_c, test3_d} and
; {test3_a, test3_b}, immediately after the newly added ref edge
; test3_a->test3_c will be converted to a call edge, and the two SCCs will be
; merged into the original one again. During this cycle, the original SCC will
; be added into UR.CWorklist again and this creates an infinite loop.

@a = global i64 0
@b = global i64 0

; Check test3_c is inlined into test3_a once and only once.
; Function Attrs: noinline
define void @test3_a() #0 {
; CHECK-LABEL: define void @test3_a
; CHECK-SAME: () #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    tail call void @test3_b()
; CHECK-NEXT:    tail call void @test3_d(i32 5)
; CHECK-NEXT:    [[T6_I:%.*]] = load i64, ptr @a, align 8
; CHECK-NEXT:    [[ADD85_I:%.*]] = add nsw i64 [[T6_I]], 1
; CHECK-NEXT:    store i64 [[ADD85_I]], ptr @a, align 8
; CHECK-NEXT:    [[T0:%.*]] = load i64, ptr @b, align 8
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[T0]], 5
; CHECK-NEXT:    store i64 [[ADD]], ptr @b, align 8
; CHECK-NEXT:    ret void
;
entry:
  tail call void @test3_b()
  tail call void @test3_c(i32 5)
  %t0 = load i64, ptr @b
  %add = add nsw i64 %t0, 5
  store i64 %add, ptr @b
  ret void
}

; Function Attrs: noinline
define void @test3_b() #0 {
; CHECK-LABEL: define void @test3_b
; CHECK-SAME: () #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    tail call void @test3_a()
; CHECK-NEXT:    [[T0:%.*]] = load i64, ptr @a, align 8
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[T0]], 2
; CHECK-NEXT:    store i64 [[ADD]], ptr @a, align 8
; CHECK-NEXT:    ret void
;
entry:
  tail call void @test3_a()
  %t0 = load i64, ptr @a
  %add = add nsw i64 %t0, 2
  store i64 %add, ptr @a
  ret void
}

define void @test3_d(i32 %i) {
; CHECK-LABEL: define void @test3_d
; CHECK-SAME: (i32 [[I:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[I]], 5
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[CALL:%.*]] = tail call i64 @random()
; CHECK-NEXT:    [[T0:%.*]] = load i64, ptr @a, align 8
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[T0]], [[CALL]]
; CHECK-NEXT:    store i64 [[ADD]], ptr @a, align 8
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    tail call void @test3_c(i32 [[I]])
; CHECK-NEXT:    tail call void @test3_b()
; CHECK-NEXT:    [[T6:%.*]] = load i64, ptr @a, align 8
; CHECK-NEXT:    [[ADD79:%.*]] = add nsw i64 [[T6]], 3
; CHECK-NEXT:    store i64 [[ADD79]], ptr @a, align 8
; CHECK-NEXT:    ret void
;
entry:
  %cmp = icmp eq i32 %i, 5
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i64 @random()
  %t0 = load i64, ptr @a
  %add = add nsw i64 %t0, %call
  store i64 %add, ptr @a
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  tail call void @test3_c(i32 %i)
  tail call void @test3_b()
  %t6 = load i64, ptr @a
  %add79 = add nsw i64 %t6, 3
  store i64 %add79, ptr @a
  ret void
}

define void @test3_c(i32 %i) {
; CHECK-LABEL: define void @test3_c
; CHECK-SAME: (i32 [[I:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[I]], 5
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[CALL:%.*]] = tail call i64 @random()
; CHECK-NEXT:    [[T0:%.*]] = load i64, ptr @a, align 8
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[T0]], [[CALL]]
; CHECK-NEXT:    store i64 [[ADD]], ptr @a, align 8
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    tail call void @test3_d(i32 [[I]])
; CHECK-NEXT:    [[T6:%.*]] = load i64, ptr @a, align 8
; CHECK-NEXT:    [[ADD85:%.*]] = add nsw i64 [[T6]], 1
; CHECK-NEXT:    store i64 [[ADD85]], ptr @a, align 8
; CHECK-NEXT:    ret void
;
entry:
  %cmp = icmp eq i32 %i, 5
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i64 @random()
  %t0 = load i64, ptr @a
  %add = add nsw i64 %t0, %call
  store i64 %add, ptr @a
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  tail call void @test3_d(i32 %i)
  %t6 = load i64, ptr @a
  %add85 = add nsw i64 %t6, 1
  store i64 %add85, ptr @a
  ret void
}

declare i64 @random()

attributes #0 = { noinline }

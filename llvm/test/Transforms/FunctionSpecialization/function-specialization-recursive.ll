; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -passes="ipsccp<func-spec>,inline,instcombine" -force-specialization -funcspec-max-iters=2 -S < %s | FileCheck %s --check-prefix=ITERS2
; RUN: opt -passes="ipsccp<func-spec>,inline,instcombine" -force-specialization -funcspec-max-iters=3 -S < %s | FileCheck %s --check-prefix=ITERS3
; RUN: opt -passes="ipsccp<func-spec>,inline,instcombine" -force-specialization -funcspec-max-iters=4 -S < %s | FileCheck %s --check-prefix=ITERS4

@low = internal constant i32 0, align 4
@high = internal constant i32 6, align 4

define internal void @recursiveFunc(ptr nocapture readonly %lo, i32 %step, ptr nocapture readonly %hi) {
; ITERS2-LABEL: define internal void @recursiveFunc
; ITERS2-SAME: (ptr nocapture readonly [[LO:%.*]], i32 [[STEP:%.*]], ptr nocapture readonly [[HI:%.*]]) {
; ITERS2-NEXT:    [[LO_TEMP:%.*]] = alloca i32, align 4
; ITERS2-NEXT:    [[HI_TEMP:%.*]] = alloca i32, align 4
; ITERS2-NEXT:    [[LO_LOAD:%.*]] = load i32, ptr [[LO]], align 4
; ITERS2-NEXT:    [[HI_LOAD:%.*]] = load i32, ptr [[HI]], align 4
; ITERS2-NEXT:    [[CMP_NOT:%.*]] = icmp eq i32 [[LO_LOAD]], [[HI_LOAD]]
; ITERS2-NEXT:    br i1 [[CMP_NOT]], label [[RET_BLOCK:%.*]], label [[BLOCK6:%.*]]
; ITERS2:       block6:
; ITERS2-NEXT:    call void @print_val(i32 [[LO_LOAD]], i32 [[HI_LOAD]])
; ITERS2-NEXT:    [[ADD:%.*]] = add nsw i32 [[LO_LOAD]], 1
; ITERS2-NEXT:    [[SUB:%.*]] = add nsw i32 [[HI_LOAD]], -1
; ITERS2-NEXT:    store i32 [[ADD]], ptr [[LO_TEMP]], align 4
; ITERS2-NEXT:    store i32 [[SUB]], ptr [[HI_TEMP]], align 4
; ITERS2-NEXT:    call void @recursiveFunc(ptr nonnull [[LO_TEMP]], i32 1, ptr nonnull [[HI_TEMP]])
; ITERS2-NEXT:    br label [[RET_BLOCK]]
; ITERS2:       ret.block:
; ITERS2-NEXT:    ret void
;
; ITERS3-LABEL: define internal void @recursiveFunc
; ITERS3-SAME: (ptr nocapture readonly [[LO:%.*]], i32 [[STEP:%.*]], ptr nocapture readonly [[HI:%.*]]) {
; ITERS3-NEXT:    [[LO_TEMP:%.*]] = alloca i32, align 4
; ITERS3-NEXT:    [[HI_TEMP:%.*]] = alloca i32, align 4
; ITERS3-NEXT:    [[LO_LOAD:%.*]] = load i32, ptr [[LO]], align 4
; ITERS3-NEXT:    [[HI_LOAD:%.*]] = load i32, ptr [[HI]], align 4
; ITERS3-NEXT:    [[CMP_NOT:%.*]] = icmp eq i32 [[LO_LOAD]], [[HI_LOAD]]
; ITERS3-NEXT:    br i1 [[CMP_NOT]], label [[RET_BLOCK:%.*]], label [[BLOCK6:%.*]]
; ITERS3:       block6:
; ITERS3-NEXT:    call void @print_val(i32 [[LO_LOAD]], i32 [[HI_LOAD]])
; ITERS3-NEXT:    [[ADD:%.*]] = add nsw i32 [[LO_LOAD]], 1
; ITERS3-NEXT:    [[SUB:%.*]] = add nsw i32 [[HI_LOAD]], -1
; ITERS3-NEXT:    store i32 [[ADD]], ptr [[LO_TEMP]], align 4
; ITERS3-NEXT:    store i32 [[SUB]], ptr [[HI_TEMP]], align 4
; ITERS3-NEXT:    call void @recursiveFunc(ptr nonnull [[LO_TEMP]], i32 1, ptr nonnull [[HI_TEMP]])
; ITERS3-NEXT:    br label [[RET_BLOCK]]
; ITERS3:       ret.block:
; ITERS3-NEXT:    ret void
;
  %lo.temp = alloca i32, align 4
  %hi.temp = alloca i32, align 4
  %lo.load = load i32, ptr %lo, align 4
  %hi.load = load i32, ptr %hi, align 4
  %cmp = icmp ne i32 %lo.load, %hi.load
  br i1 %cmp, label %block6, label %ret.block

block6:
  call void @print_val(i32 %lo.load, i32 %hi.load)
  %add = add nsw i32 %lo.load, %step
  %sub = sub nsw i32 %hi.load, %step
  store i32 %add, ptr %lo.temp, align 4
  store i32 %sub, ptr %hi.temp, align 4
  call void @recursiveFunc(ptr nonnull %lo.temp, i32 %step, ptr nonnull %hi.temp)
  br label %ret.block

ret.block:
  ret void
}

define i32 @main() {
; ITERS2-LABEL: define i32 @main() {
; ITERS2-NEXT:    call void @print_val(i32 0, i32 6)
; ITERS2-NEXT:    call void @print_val(i32 1, i32 5)
; ITERS2-NEXT:    call void @recursiveFunc(ptr nonnull @funcspec.arg.4, i32 1, ptr nonnull @funcspec.arg.5)
; ITERS2-NEXT:    ret i32 0
;
; ITERS3-LABEL: define i32 @main() {
; ITERS3-NEXT:    call void @print_val(i32 0, i32 6)
; ITERS3-NEXT:    call void @print_val(i32 1, i32 5)
; ITERS3-NEXT:    call void @print_val(i32 2, i32 4)
; ITERS3-NEXT:    call void @recursiveFunc(ptr nonnull @funcspec.arg.7, i32 1, ptr nonnull @funcspec.arg.8)
; ITERS3-NEXT:    ret i32 0
;
; ITERS4-LABEL: define i32 @main() {
; ITERS4-NEXT:    call void @print_val(i32 0, i32 6)
; ITERS4-NEXT:    call void @print_val(i32 1, i32 5)
; ITERS4-NEXT:    call void @print_val(i32 2, i32 4)
; ITERS4-NEXT:    ret i32 0
;
  call void @recursiveFunc(ptr nonnull @low, i32 1, ptr nonnull @high)
  ret i32 0
}

declare dso_local void @print_val(i32, i32)
